#
# * Copyright 2010, Google Inc.
# *
# * ***** BEGIN LICENSE BLOCK *****
# * Version: MPL 1.1
# *
# * The contents of this file are subject to the Mozilla Public License Version
# * 1.1 (the "License"); you may not use this file except in compliance with
# * the License. You may obtain a copy of the License at
# * http://www.mozilla.org/MPL/
# *
# * Software distributed under the License is distributed on an "AS IS" basis,
# * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# * for the specific language governing rights and limitations under the
# * License.
# *
# * The Original Code is the GPG Browser Bridge.
# *
# * The Initial Developer of the Original Code is Google Inc.
# *
# * Portions created by the Initial Developer are Copyright (C) 2010
# * the Initial Developer. All Rights Reserved.
# *
# * Contributor(s):
# *   Phil Dibowitz <fixxxer@google.com>
# *   Fredrik Roubert <roubert@google.com>
# *   Phil Ames <philames@google.com>
# *
# * ***** END LICENSE BLOCK *****
#

import os
import sys

IDL_SOURCES=['types.idl', 'gnupg.idl']
SOURCES=['gnupg.cc', 'logging.cc', 'plugin.cc', 'prefs.cc', 'tmpwrapper.cc']
GLUE_SOURCES=['common.cc', 'npn_api.cc', 'main.cc']
# static_object.cc is a special case since it is required for gnupg_unittest,
# but including the other NPAPI sources above results in redefinition of
# methods that are stubbed out in gnupg_unittest.cc (e.g. the NPN_xxx methods).
STATIC_OBJ_GLUE_SOURCES=['static_object.cc']

if sys.platform == 'win32':
    NSPR_DIR = '/xulrunner-sdk/include'
    RESOURCES = ['npgnupg.rc']
    SOURCES.append('createprocess.cc')
else:
    NSPR_DIR = '/usr/include/nspr'
    RESOURCES = []

env = Environment(
    TARGET_ARCH = 'x86', # Used when building using 64-bit Windows.
    THIRD_PARTY = '../third_party',
    NIXYSA_DIR = '$THIRD_PARTY/nixysa/nixysa',
    PRSTREAMS_DIR = '$THIRD_PARTY/prstreams',
    STATIC_GLUE_DIR = '$NIXYSA_DIR/static_glue/npapi',
    NPAPI_DIR = '$THIRD_PARTY/nixysa/third_party/npapi/include',
    GLUE_DIR = 'glue',
    NSPR_DIR = NSPR_DIR,
    CPPPATH=['.', '$STATIC_GLUE_DIR', '$NPAPI_DIR', '$GLUE_DIR',
             '$PRSTREAMS_DIR', '$NSPR_DIR'],
    LIBS=['nspr4']
)
env.Append(ENV={'PYTHON': sys.executable})
if env['CC'] == 'cl':
    env.Append(CCFLAGS = ['/MT', '/EHsc'])
    WARNFLAGS = ['/W3']
else:
    WARNFLAGS = ['-Wall', '-Werror']
if sys.platform == 'win32':
  env.Append(CODEGEN = 'codegen.bat',
             CPPDEFINES = [
               '_WINDOWS', # npapi.h: Configure for Windows.
               '_X86_', # winnt.h: Necessary to define when _WINDOWS is defined.
               'WIN32_LEAN_AND_MEAN', # windows.h: Exclude rarely-used services.
               'NOMINMAX', # windef.h: Get standard C++ min() and max().
               'OS_WINDOWS'],
             LIBPATH = ['/xulrunner-sdk/lib'])
elif sys.platform == 'darwin':
  env.Append(CODEGEN = 'codegen.sh',
             CPPDEFINES = ['XP_MACOSX', 'OS_MACOSX'],
             LINKFLAGS = '-framework CoreFoundation -framework IOKit')
else:
  env.Append(CODEGEN = 'codegen.sh',
             CPPDEFINES = ['OS_LINUX'])

# Up to this point, the same Environment is shared between plugin and unittest.
test_env = env.Clone()

if env['CC'] == 'cl':
  env.Append(LINKFLAGS = '/def:npgnupg.def')

def NixysaEmitter(target, source, env):
  bases = [os.path.splitext(s.name)[0] for s in source] + ['globals']
  targets = ['$GLUE_DIR/%s_glue.cc' % b for b in bases]
  targets += ['$GLUE_DIR/%s_glue.h' % b for b in bases]
  targets += ['$GLUE_DIR/hash', '$GLUE_DIR/parsetab.py']
  return targets, source

NIXYSA_CMDLINE = ' '.join([env.File('$NIXYSA_DIR/$CODEGEN').abspath,
                           '--output-dir=$GLUE_DIR',
                           '--generate=npapi',
                           '$SOURCES'])

env['BUILDERS']['Nixysa'] = Builder(action=NIXYSA_CMDLINE,
                                    emitter=NixysaEmitter)

AUTOGEN_OUTPUT = env.Nixysa(IDL_SOURCES)
AUTOGEN_CC_FILES = [f for f in AUTOGEN_OUTPUT if f.suffix == '.cc']

prstreams = [env.SharedObject('$PRSTREAMS_DIR/prstrms.cpp',
                              CCFLAGS=env['CCFLAGS'] + WARNFLAGS)]

#
# We manually make these objects separately so we can pass in -Wall
# and -Werror, but not to the generated content
#
objs = [env.SharedObject(s, CCFLAGS=env['CCFLAGS'] + WARNFLAGS)
        for s in SOURCES]
static_obj_glue_objs = [env.SharedObject(s) for s in ['$STATIC_GLUE_DIR/' + f
                        for f in STATIC_OBJ_GLUE_SOURCES]]
glue_objs = [env.SharedObject(s) for s in ['$STATIC_GLUE_DIR/' + f for f in
               GLUE_SOURCES]]
nixysa_objs = [static_obj_glue_objs + glue_objs]
plugin = env.SharedLibrary('npgnupg', AUTOGEN_CC_FILES + objs + prstreams +
                           nixysa_objs + [env.RES(f) for f in RESOURCES])

# TODO(philames): Create a build rule that will copy
# src/extensions/common/gpg_common.js to the  appropriate directory for each
# extension.

# TESTS
#
# Note that it's necessary to use the gtest that comes with gmock (ie. the
# gtest used to build gmock), and not any random gtest. This should be taken
# care of for you if you installed the libraries using any decent package
# system.
#
# The nixysa framework makes .o files called .os files... they're *identical*
# so we compile that into the test instead of *also* building static libraries.
#
test_env.Append(LIBS=['gmock'])

if sys.platform == 'win32':
  test_env.Append(CPPPATH=['../../gmock-1.5.0/gtest/include',
                           '../../gmock-1.5.0/include'],
                  LIBPATH=['../../gmock-1.5.0/msvc/Release'],
                  LINKFLAGS = ['/LTCG'])
else:
  test_env.Append(LIBS=['gtest'])

unittest = test_env.Program(target='gnupg_unittest',
                            source = [objs + prstreams + static_obj_glue_objs,
                            'gnupg_unittest.cc', 'tmpwrapper_unittest.cc'])

Default(plugin)
