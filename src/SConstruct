#
# * Copyright 2010, Google Inc.
# *
# * ***** BEGIN LICENSE BLOCK *****
# * Version: MPL 1.1
# *
# * The contents of this file are subject to the Mozilla Public License Version
# * 1.1 (the "License"); you may not use this file except in compliance with
# * the License. You may obtain a copy of the License at
# * http://www.mozilla.org/MPL/
# *
# * Software distributed under the License is distributed on an "AS IS" basis,
# * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
# * for the specific language governing rights and limitations under the
# * License.
# *
# * The Original Code is the GPG Browser Bridge.
# *
# * The Initial Developer of the Original Code is Google Inc.
# *
# * Portions created by the Initial Developer are Copyright (C) 2010
# * the Initial Developer. All Rights Reserved.
# *
# * Contributor(s):
# *   Phil Dibowitz <fixxxer@google.com>
# *   Fredrik Roubert <roubert@google.com>
# *   Phil Ames <philames@google.com>
# *
# * ***** END LICENSE BLOCK *****
#

import os
import sys

IDL_SOURCES=['types.idl', 'gnupg.idl']
SOURCES=['gnupg.cc', 'logging.cc', 'plugin.cc', 'prefs.cc', 'tmpwrapper.cc']
STATIC_GLUE_SOURCES=['common.cc', 'npn_api.cc', 'static_object.cc', 'main.cc']

if sys.platform == 'win32':
    NSPR_DIR = '/xulrunner-sdk/include'
    RESOURCES = ['npgnupg.rc']
    SOURCES.append('createprocess.cc')
else:
    NSPR_DIR = '/usr/include/nspr'
    RESOURCES = []

env = Environment(
    THIRD_PARTY = '../third_party',
    NIXYSA_DIR = '$THIRD_PARTY/nixysa/nixysa',
    PRSTREAMS_DIR = '$THIRD_PARTY/prstreams',
    STATIC_GLUE_DIR = '$NIXYSA_DIR/static_glue/npapi',
    NPAPI_DIR = '$THIRD_PARTY/nixysa/third_party/npapi/include',
    GLUE_DIR = 'glue',
    NSPR_DIR = NSPR_DIR,
    CPPPATH=['.', '$STATIC_GLUE_DIR', '$NPAPI_DIR', '$GLUE_DIR',
             '$PRSTREAMS_DIR', '$NSPR_DIR'],
    LIBS=['nspr4']
)
env.Append(ENV={'PYTHON': sys.executable})
if env['CC'] == 'cl':
    env.Append(CCFLAGS = ['/MT', '/EHsc'],
               LINKFLAGS = '/def:npgnupg.def')
    WARNFLAGS = ['/W3']
else:
    WARNFLAGS = ['-Wall', '-Werror']
if sys.platform == 'win32':
  env.Append(CODEGEN = 'codegen.bat',
             CPPDEFINES = [
               '_WINDOWS', # npapi.h: Configure for Windows.
               '_X86_', # winnt.h: Necessary to define when _WINDOWS is defined.
               'WIN32_LEAN_AND_MEAN', # windows.h: Exclude rarely-used services.
               'NOMINMAX', # windef.h: Get standard C++ min() and max().
               'OS_WINDOWS'],
             LIBPATH = ['/xulrunner-sdk/lib'])
elif sys.platform == 'darwin':
  env.Append(CODEGEN = 'codegen.sh',
             CPPDEFINES = ['XP_MACOSX', 'OS_MACOSX'],
             LINKFLAGS = '-framework CoreFoundation -framework IOKit')
else:
  env.Append(CODEGEN = 'codegen.sh',
             CPPDEFINES = ['OS_LINUX'])

def NixysaEmitter(target, source, env):
  bases = [os.path.splitext(s.name)[0] for s in source] + ['globals']
  targets = ['$GLUE_DIR/%s_glue.cc' % b for b in bases]
  targets += ['$GLUE_DIR/%s_glue.h' % b for b in bases]
  targets += ['$GLUE_DIR/hash', '$GLUE_DIR/parsetab.py']
  return targets, source

NIXYSA_CMDLINE = ' '.join([env.File('$NIXYSA_DIR/$CODEGEN').abspath,
                           '--output-dir=$GLUE_DIR',
                           '--generate=npapi',
                           '$SOURCES'])

env['BUILDERS']['Nixysa'] = Builder(action=NIXYSA_CMDLINE,
                                    emitter=NixysaEmitter)

AUTOGEN_OUTPUT = env.Nixysa(IDL_SOURCES)
AUTOGEN_CC_FILES = [f for f in AUTOGEN_OUTPUT if f.suffix == '.cc']

prstreams = [env.SharedObject('$PRSTREAMS_DIR/prstrms.cpp',
                              CCFLAGS=env['CCFLAGS'] + WARNFLAGS)]

#
# We manually make these objects separately so we can pass in -Wall
# and -Werror, but not to the generated content
#
objs = [env.SharedObject(s, CCFLAGS=env['CCFLAGS'] + WARNFLAGS)
        for s in SOURCES]
plugin = env.SharedLibrary('npgnupg', AUTOGEN_CC_FILES + objs + prstreams +
                           [env.RES(f) for f in RESOURCES] +
                           ['$STATIC_GLUE_DIR/' + f
                            for f in STATIC_GLUE_SOURCES])

# TODO(philames): Create a build rule that will copy
# src/extensions/common/gpg_common.js to the  appropriate directory for each
# extension.

# TESTS
# #
# Note that while many distributions have a gtest, you really need to use the
# gtest that comes with gmock, if you want to use gmock. So that's what we do
# here.
if 'gnupg_unittest' in COMMAND_LINE_TARGETS:
  TP_DIR = '../third_party'
  GMOCK_DIR = TP_DIR + '/gmock'
  GTEST_DIR = GMOCK_DIR + '/gtest'
  Export('env')
  gtest_dir = env.Dir('.')
  gtest_dir.addRepository(env.Dir(GTEST_DIR))

  env.Append(CPPPATH=['../' + GTEST_DIR + '/include',
                      '../' + GMOCK_DIR + '/include'])
  env.SConscript(env.File('scons/SConscript', gtest_dir))
  #
  # The nixysa framework makes .o files called .os files... they're *identical*
  # so we compile that into the test instead of *also* building static libraries.
  #
  env.Append(CPPPATH=[GTEST_DIR + '/include', GMOCK_DIR + '/include'])
  env.Program(target='gnupg_unittest',
              source = [objs + prstreams,
                        'gnupg_unittest.cc', 'tmpwrapper_unittest.cc',
                        GMOCK_DIR + '/lib/.libs/libgmock.a',
                        GTEST_DIR + '/lib/.libs/libgtest.a'],
              LIBS=['nspr4', 'pthread'],
              LIBPATH=['scons',
                       GMOCK_DIR + '/lib/.libs',
                       GTEST_DIR + '/lib/.libs'])

Default(plugin)
